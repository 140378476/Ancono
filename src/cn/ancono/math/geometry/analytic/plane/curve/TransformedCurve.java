/**
 *
 */
package cn.ancono.math.geometry.analytic.plane.curve;

import cn.ancono.math.MathCalculator;
import cn.ancono.math.MathObject;
import cn.ancono.math.geometry.analytic.plane.PAffineTrans;
import cn.ancono.math.geometry.analytic.plane.Point;
import cn.ancono.math.numberModels.api.FlexibleNumberFormatter;
import org.jetbrains.annotations.NotNull;

import java.util.function.Function;

/**
 * TransformedCurve is a wrapper class to describe a PlaneCurve which is the new curve generated by 
 * the original one through a plane affine transformation.
 * @author liyicheng
 *
 */
public final class TransformedCurve<T> extends AbstractPlaneCurve<T> {
    private final AbstractPlaneCurve<T> original;
    /**
     * The transformation to original curve
     */
    private final PAffineTrans<T> backward;

    /**
     * @param mc
     */
    protected TransformedCurve(MathCalculator<T> mc, AbstractPlaneCurve<T> original, PAffineTrans<T> bk) {
        super(mc);
        this.original = original;
        backward = bk;
    }

    public AbstractPlaneCurve<T> getOriginal() {
        return original;
    }

    /**
     * Returns the transformation that should be performed before testing contains.
     * @return
     */
    public PAffineTrans<T> getBackwardTrans() {
        return backward;
    }

    /* (non-Javadoc)
     * @see cn.ancono.math.geometry.analytic.planeAG.PlaneCurve#contains(cn.ancono.math.geometry.analytic.planeAG.Point)
     */
    @Override
    public boolean contains(Point<T> p) {
        return original.contains(backward.apply(p));
    }
    /* (non-Javadoc)
     * @see cn.ancono.math.FlexibleMathObject#mapTo(java.util.function.Function, cn.ancono.math.number_models.MathCalculator)
     */

    @NotNull
    @Override
    public <N> TransformedCurve<N> mapTo(@NotNull Function<T, N> mapper, @NotNull MathCalculator<N> newCalculator) {
        // this should be assured that the returned type is a plane curve of type N.
        AbstractPlaneCurve<N> npc = original.mapTo(mapper, newCalculator);
        return new TransformedCurve<N>(newCalculator, npc, backward.mapTo(mapper, newCalculator));
    }

    /* (non-Javadoc)
     * @see cn.ancono.math.FlexibleMathObject#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof TransformedCurve)) {
            return false;
        }
        TransformedCurve<?> tc = (TransformedCurve<?>) obj;
        return original.equals(tc.original) && backward.equals(tc.backward);
    }

    /* (non-Javadoc)
     * @see cn.ancono.math.FlexibleMathObject#valueEquals(cn.ancono.math.FlexibleMathObject)
     */
    @Override
    public boolean valueEquals(@NotNull MathObject<T> obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof TransformedCurve)) {
            return false;
        }
        TransformedCurve<T> tc = (TransformedCurve<T>) obj;
        return original.valueEquals(tc.original) && backward.valueEquals(tc.backward);
    }

    /* (non-Javadoc)
     * @see cn.ancono.math.FlexibleMathObject#valueEquals(cn.ancono.math.FlexibleMathObject, java.util.function.Function)
     */
    @Override
    public <N> boolean valueEquals(@NotNull MathObject<N> obj, @NotNull Function<N, T> mapper) {
        if (!(obj instanceof TransformedCurve)) {
            return false;
        }
        TransformedCurve<N> tc = (TransformedCurve<N>) obj;
        return original.valueEquals(tc.original, mapper) && backward.valueEquals(tc.backward, mapper);
    }

    /* (non-Javadoc)
     * @see cn.ancono.math.FlexibleMathObject#toString(cn.ancono.math.number_models.NumberFormatter)
     */
    @Override
    public String toString(@NotNull FlexibleNumberFormatter<T, MathCalculator<T>> nf) {
        StringBuilder sb = new StringBuilder(64);
        sb.append("TransformedCurve:original=").append(original.toString(nf)).append(", inversed transformation=").append(backward.toString(nf));
        return sb.toString();
    }


}
