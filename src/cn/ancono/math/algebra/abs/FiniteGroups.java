/*
  2018-02-27
 */
package cn.ancono.math.algebra.abs;

import cn.ancono.math.algebra.abs.calculator.EqualPredicate;
import cn.ancono.math.algebra.abs.calculator.GroupCalculator;
import cn.ancono.math.algebra.abs.calculator.GroupCalculatorKt;
import cn.ancono.math.algebra.abs.group.finite.AbstractFiniteGroup;
import cn.ancono.math.algebra.abs.group.finite.CyclicGroup;
import cn.ancono.math.algebra.abs.structure.finite.FiniteGroup;
import cn.ancono.math.discrete.combination.Permutation;
import cn.ancono.math.discrete.combination.Permutations;
import cn.ancono.math.function.Bijection;
import cn.ancono.math.function.MathBinaryOperator;
import cn.ancono.math.set.FiniteSet;
import cn.ancono.math.set.Interval;
import cn.ancono.math.set.MathSets;
import cn.ancono.utilities.ArraySup;
import cn.ancono.utilities.CollectionSup;
import kotlin.Pair;
import org.jetbrains.annotations.NotNull;

import java.lang.reflect.Array;
import java.util.*;

/**
 * A utility class for finite groups.
 *
 * @author liyicheng
 * 2018-02-27 17:52
 */
public final class FiniteGroups {

    /**
     *
     */
    private FiniteGroups() {
    }

    static class FiniteGroupImpl<T> extends AbstractFiniteGroup<T> {

        private final FiniteSet<T> set;
        private final GroupCalculator<T> gc;

        /**
         *
         */
        public FiniteGroupImpl(GroupCalculator<T> gc, FiniteSet<T> set) {
            this.gc = gc;
            this.set = set;
        }

        @Override
        public GroupCalculator<T> getCalculator() {
            return gc;
        }

        /*
         * @see cn.ancono.math.algebra.abstractAlgebra.structure.LimitedGroup#getSet()
         */
        @Override
        public FiniteSet<T> getSet() {
            return set;
        }


        /*
         * @see cn.ancono.math.algebra.abstractAlgebra.structure.Group#index()
         */
        @Override
        public long index() {
            return set.size();
        }
    }


    public static <T, N> AbstractFiniteGroup<N> isomorphism(FiniteGroup<T> g, Bijection<T, N> mapping) {
        GroupCalculator<N> gc = GroupCalculators.INSTANCE.isomorphism(g.getCalculator(), mapping);
        FiniteSet<N> set = g.getSet().mapTo(mapping);
        return new FiniteGroupImpl<>(gc, set);
    }

    public static <T, N> AbstractFiniteGroup<N> isomorphism(FiniteGroup<T> g, GroupCalculator<N> ngc, IsomorphismMapping<T, N> mapping) {
        FiniteSet<N> set = g.getSet().mapTo(mapping);
        return new FiniteGroupImpl<>(ngc, set);
    }


    /**
     * Generates a group table, the group table is a two-dimension array. The length
     * of each dimension is <i>size of the group</i>.
     * <p></p> Note that this group table is generally isomorphic
     * to the group table generated by {@linkplain FiniteGroup#groupTable()}
     */
    public static <T> T[][] generateGroupTable(FiniteGroup<T> g) {
        FiniteSet<T> set = g.getSet();
        int size = ArraySup.castToArrayLength(set.size());
        MathBinaryOperator<T> f = g.getCalculator();
        @SuppressWarnings("unchecked")
        T[][] arr = (T[][]) Array.newInstance(g.getCalculator().getNumberClass(), size, size);
        {
            int i = 0;
            for (T t : set) {
                arr[0][i] = t;
                arr[i][0] = t;
                i++;
            }
        }//TODO check correctness
        for (int i = 1; i < size; i++) {
            for (int j = 1; j < size; j++) {
                arr[i][j] = f.apply(arr[i][0], arr[0][j]);
            }
        }

        return arr;
    }


    /**
     * Creates a group containing all the given elements and the elements that they generate.
     *
     * @param gc       a group calculator
     * @param elements an array of elements
     * @return a finite group
     */
    @SafeVarargs
    public static <T> AbstractFiniteGroup<T> createGroup(GroupCalculator<T> gc, T... elements) {
        List<T> list = new ArrayList<>(elements.length + 1);
        list.add(gc.getIdentity());
        OUTER:
        for (T x : elements) {
            for (T y : list) {
                if (gc.isEqual(x, y)) {
                    continue OUTER;
                }
            }
            list.add(x);
        }
        generateList(list, gc);
        FiniteSet<T> set = MathSets.fromCollection(list, GroupCalculators.INSTANCE.toMathCalculatorAdd(gc));
        return new FiniteGroupImpl<>(gc, set);
    }

    /**
     * Creates a group containing all the given elements and the elements that they generate.
     *
     * @param gc       a group calculator
     * @param elements a collection of elements,
     */
    public static <T> AbstractFiniteGroup<T> createGroup(GroupCalculator<T> gc, Collection<T> elements) {
        return createGroup0(gc, elements.size(), elements);
    }

    /**
     * Creates a group containing all the given elements and the elements that they generate.
     *
     * @param gc       a group calculator
     * @param elements a finite set of elements,
     */
    public static <T> AbstractFiniteGroup<T> createGroup(GroupCalculator<T> gc, FiniteSet<T> elements) {
        return createGroup0(gc, Math.toIntExact(elements.size()), elements);
    }

    /**
     * Creates a group whose elements are given without check whether they actually form a group.
     *
     * @param gc       a calculator
     * @param elements all the elements in this group
     */
    @SafeVarargs
    public static <T> AbstractFiniteGroup<T> createGroupWithoutCheck(GroupCalculator<T> gc, T... elements) {
        FiniteSet<T> set = MathSets.asSet(gc, elements);
        return new FiniteGroupImpl<>(gc, set);
    }

    /**
     * Creates a group whose elements are given without check whether they actually form a group.
     *
     * @param gc       a calculator
     * @param elements all the elements in this group
     */
    public static <T> AbstractFiniteGroup<T> createGroupWithoutCheck(GroupCalculator<T> gc, Collection<T> elements) {
        FiniteSet<T> set = MathSets.fromCollection(elements, gc);
        return new FiniteGroupImpl<>(gc, set);
    }

    /**
     * Creates a group whose elements are given without check whether they actually form a group.
     *
     * @param gc  a calculator
     * @param set all the elements in this group
     */
    public static <T> AbstractFiniteGroup<T> createGroupWithoutCheck(GroupCalculator<T> gc, FiniteSet<T> set) {
        return new FiniteGroupImpl<>(gc, set);
    }

    /**
     * Creates a finite group from the group table, this method will check if
     * the group table is valid.
     * <ul>
     * <li>Firstly, each single row and single column must contain distinct elements.
     * <li>Secondly, the first row and the first column must be
     * the same in elements and their order, and the first element must be the identity element.
     * <li>Thirdly, the element in the table table[i][j] is the result of apply(table[i][0],table[0][j]).
     * <li>Lastly, the accordingly defined operation must be associative.
     * </ul>
     *
     * @param table the group table
     */
    public static <T> AbstractFiniteGroup<T> createFromGroupTable(T[][] table) {
        T[] elements = table[0];
        HashMap<T, Integer> map = new HashMap<>();
        for (int i = 0; i < elements.length; i++) {
            map.put(elements[i], i);
        }
        if (map.size() != elements.length) {
            throw new IllegalArgumentException();
        }
        @SuppressWarnings("NullableProblems")
        Bijection<Integer, T> bi = Bijection.of(x -> elements[x], map::get);
        int[][] tableInt = ArraySup.mapTo2(table, map::get);
        var gInt = createFromGroupTable(tableInt);
        return new FiniteGroupImpl<>(GroupCalculators.INSTANCE.isomorphism(gInt.getCalculator(), bi),
                MathSets.asSet(elements));
    }

    public static <T> AbstractFiniteGroup<T> createFromGroupTableWithoutCheck(T[][] table, boolean isCommutative) {
        T[] elements = table[0];
        var bi = Bijection.indexMapping(elements);
        int[][] tableInt = ArraySup.mapTo2(table, bi::deply);
        var gInt = createFromGroupTableWithoutCheck(tableInt, isCommutative);
        return new FiniteGroupImpl<>(GroupCalculators.INSTANCE.isomorphism(gInt.getCalculator(), bi),
                MathSets.asSet(elements));
    }

    /**
     * Creates a finite group of integer from the group table, this method will check if
     * the group table is valid.
     * <ul>
     * <li>Firstly, each single row and single column must contain distinct elements.
     * <li>Secondly, the first row and the first column must be <code>0,1,...,n</code>.
     * <li>Thirdly, the element in the table table[i][j] is the result of apply(table[i][0],table[0][j]).
     * <li>Lastly, the accordingly defined operation must be associative.
     * </ul>
     *
     * @param table the group table
     */
    public static AbstractFiniteGroup<Integer> createFromGroupTable(int[][] table) {
        int size = table.length;

        for (int[] row : table) {
            if (row.length != size) {
                throw new IllegalArgumentException();
            }
            boolean[] contains = new boolean[size];
            for (int i : row) {
                if (contains[i]) {
                    throw new IllegalArgumentException();
                }
                contains[i] = true;
            }
        }

        for (int i = 0; i < size; i++) {
            if (table[i][0] != i || table[i][0] != table[0][i]) {
                throw new IllegalArgumentException();
            }
        }

        for (int a = 1; a < size; a++) {
            for (int b = 1; b < size; b++) {
                int ab = table[a][b];
                for (int c = 0; c < size; c++) {
                    int re1 = table[ab][c];
                    int bc = table[b][c];
                    int re2 = table[a][bc];
                    if (re1 != re2) {
                        throw new IllegalArgumentException("Not Associative!");
                    }
                }
            }
        }

        //commutative check
        boolean isCommutative = true;
        OUTER:
        for (int a = 1; a < size; a++) {
            for (int b = 1; b < a; b++) {
                if (table[a][b] != table[b][a]) {
                    isCommutative = false;
                    break OUTER;
                }
            }
        }
        return createFromGroupTableWithoutCheck(table, isCommutative);
    }

    public static AbstractFiniteGroup<Integer> createFromGroupTableWithoutCheck(int[][] table, boolean isCommutative) {
        int size = table.length;
        var gc = new GroupCalculator<Integer>() {
            @Override
            public boolean isCommutative() {
                return isCommutative;
            }

            @Override
            public boolean isEqual(@NotNull Integer x, @NotNull Integer y) {
                return x.equals(y);
            }

            @NotNull
            @Override
            public Integer apply(@NotNull Integer x, @NotNull Integer y) {
                return table[x][y];
            }

            @NotNull
            @Override
            public Integer getIdentity() {
                return 0;
            }

            @NotNull
            @Override
            public Integer inverse(@NotNull Integer x) {
                int x_ = x;
                for (int i = 0; i < size; i++) {
                    if (table[i][x_] == 0) {
                        return i;
                    }
                }
                throw new ArithmeticException();
            }
        };
        return new FiniteGroupImpl<>(gc, Interval.rangeOf(0, size));
    }


    public static <T> AbstractFiniteGroup<T> createFromGroupTableAndElements(int[][] table, T[] elements) {
        HashMap<T, Integer> map = new HashMap<>();
        for (int i = 0; i < elements.length; i++) {
            map.put(elements[i], i);
        }
        if (map.size() != elements.length) {
            throw new IllegalArgumentException();
        }
        @SuppressWarnings("NullableProblems")
        Bijection<Integer, T> bi = Bijection.of(x -> elements[x], map::get);
        var gInt = createFromGroupTable(table);
        return new FiniteGroupImpl<>(GroupCalculators.INSTANCE.isomorphism(gInt.getCalculator(), bi),
                MathSets.asSet(elements));
    }


    private static <T> AbstractFiniteGroup<T> createGroup0(GroupCalculator<T> f, int size, Iterable<T> elements) {
        List<T> list = new ArrayList<>(size + 1);
        list.add(f.getIdentity());
        OUTER:
        for (T x : elements) {
            for (T y : list) {
                if (f.isEqual(x, y)) {
                    continue OUTER;
                }
            }
            list.add(x);
        }
        generateList(list, f);
        FiniteSet<T> set = MathSets.fromCollection(list, GroupCalculators.toMathCalculatorAdd(f));
        return new FiniteGroupImpl<>(f, set);
    }


    private static <T> void generateList(List<T> list, GroupCalculator<T> f) {
        for (int i = 1; i < list.size(); i++) {
            T x = list.get(i);
            for (int j = 1; j < list.size(); j++) {
                T y = list.get(j);
                T z = f.apply(x, y);
                boolean contains = false;
                for (T t : list) {
                    if (f.isEqual(t, z)) {
                        contains = true;
                        break;
                    }
                }
                if (!contains) {
                    list.add(z);
                }

            }
        }
    }

    private static <T> SortedSet<T> generateComparable(SortedSet<T> s, GroupCalculator<T> f) {
        var results = new TreeSet<>(s);
        Collection<T> n1 = s;
        while (!n1.isEmpty()) {
            var n2 = new ArrayList<T>();
            for (var x : n1) {
                for (var y : results) {
                    var z = f.apply(x, y);
                    if (results.add(z)) {
                        n2.add(z);
                    }
                }
            }
            n1 = n2;
        }
        return results;
    }

    /**
     * Creates a group that only contains the identity element.
     *
     * @param gc a group calculator
     * @return a group
     */
    public static <T> AbstractFiniteGroup<T> identityGroup(GroupCalculator<T> gc) {
        return new FiniteGroupImpl<>(gc, MathSets.singleton(gc.getIdentity(), gc));
    }

    /**
     * Creates a group that only contains the identity element.
     *
     * @param e the identity element.
     * @return a group
     */
    public static <T> AbstractFiniteGroup<T> identityGroup(T e) {
        return identityGroup(new GroupCalculator<>() {
            @Override
            public boolean isCommutative() {
                return true;
            }

            @Override
            public boolean isEqual(@NotNull T x, @NotNull T y) {
                return x == y;
            }

            @NotNull
            @Override
            public T apply(@NotNull T x, @NotNull T y) {
                return e;
            }

            @NotNull
            @Override
            public T getIdentity() {
                return e;
            }

            @NotNull
            @Override
            public T inverse(@NotNull T x) {
                return e;
            }
        });
    }


    public static AbstractFiniteGroup<Integer> BINARY_GROUP_INT = createFromGroupTableWithoutCheck(
            new int[][]{
                    {0, 1},
                    {1, 0}
            }, true
    );

    /**
     * Returns a binary group that only contains two elements, where <code>a*a = e</code>
     *
     * @param e the identity element
     * @param a another element
     */
    public static <T> AbstractFiniteGroup<T> binaryGroup(T e, T a) {
        Objects.requireNonNull(e);
        Objects.requireNonNull(a);
        if (e == a) {
            throw new IllegalArgumentException("e == a");
        }
        var set = MathSets.asSet(EqualPredicate.refEqual(), e, a);
        GroupCalculator<T> cal = new GroupCalculator<>() {
            @Override
            public boolean isCommutative() {
                return true;
            }

            @Override
            public boolean isEqual(@NotNull T x, @NotNull T y) {
                return x == y;
            }

            @NotNull
            @Override
            public T apply(@NotNull T x, @NotNull T y) {
                if (x == e) {
                    return y;
                }
                if (y == e) {
                    return x;
                }
                return e;
            }

            @NotNull
            @Override
            public T getIdentity() {
                return e;
            }

            @NotNull
            @Override
            public T inverse(@NotNull T x) {
                return x;
            }
        };

        return new FiniteGroupImpl<>(cal, set);
    }

    public static AbstractFiniteGroup<Integer> TRIPLE_GROUP_INT = createFromGroupTableWithoutCheck(
            new int[][]{
                    {0, 1, 2},
                    {1, 2, 0},
                    {2, 0, 1}
            }, true
    );

    /**
     * Returns a finite group containing the given three elements.
     */
    public static <T> AbstractFiniteGroup<T> tripleGroup(T e, T a, T b) {
        Objects.requireNonNull(e);
        Objects.requireNonNull(a);
        Objects.requireNonNull(b);
        if (e == a || e == b || a == b) {
            throw new IllegalArgumentException();
        }
        // 0 1 2
        // 1 2 0
        // 2 0 1
        var set = MathSets.asSet(EqualPredicate.refEqual(), e, a, b);
        var cal = new GroupCalculator<T>() {

            @Override
            public boolean isEqual(@NotNull T x, @NotNull T y) {
                return x == y;
            }

            @Override
            public boolean isCommutative() {
                return true;
            }

            @NotNull
            @Override
            public T apply(@NotNull T x, @NotNull T y) {
                if (x == e) {
                    return y;
                }
                if (y == e) {
                    return x;
                }
                if (x == a) {
                    if (y == a) {
                        return b;
                    } else {
                        return a;
                    }
                }
                if (x == b) {
                    if (y == a) {
                        return a;
                    } else {
                        return a;
                    }
                }
                throw new ArithmeticException("Not contain: " + x);
            }

            @NotNull
            @Override
            public T getIdentity() {
                return e;
            }

            @NotNull
            @Override
            public T inverse(@NotNull T x) {
                if (x == e) {
                    return e;
                } else if (x == a) {
                    return b;
                }
                return a;
            }
        };
        return new FiniteGroupImpl<>(cal, set);
    }


    public static <T> AbstractFiniteGroup<T> fourCyclicGroup(T e, T a, T b, T c) {
        return isomorphism(CyclicGroup.createGroup(4), Bijection.indexMapping(e, a, b, c));
    }


    public static AbstractFiniteGroup<Integer> KLEIN_FOUR_GROUP_INT = createFromGroupTableWithoutCheck(
            new int[][]{
                    {0, 1, 2, 3},
                    {1, 0, 3, 2},
                    {2, 3, 0, 1},
                    {3, 2, 1, 0}
            }, true
    );


    /**
     * Returns the Klein four-element group.
     */
    public static <T> AbstractFiniteGroup<T> klienFourGroup(T e, T a, T b, T c) {
        /*
        * 	e 	a 	b 	c
        e 	e 	a 	b 	c
        a 	a 	e 	c 	b
        b 	b 	c 	e 	a
        c 	c 	b 	a 	e
         */
        return isomorphism(KLEIN_FOUR_GROUP_INT, Bijection.indexMapping(e, a, b, c));
    }

    /**
     * Determines whether the two finite groups are isomorphic.
     */
    public static boolean isIsomorphic(FiniteGroup<?> g1, FiniteGroup<?> g2) {
        if (g1.index() != g2.index()) {
            return false;
        }
        int[][] table1 = g1.groupTable(),
                table2 = g2.groupTable();
        int size = Math.toIntExact(g1.index());
        int[] map = ArraySup.fillArr(size, -1);
        //identity element must be equal
        map[0] = 0;
        map = recurEqual(size, table1, table2, map, 0);
        return map != null;
    }

    /**
     * Determines whether the two finite groups are isomorphic and returns the isomorphism as a permutation
     * <code>p</code>, which maps the i-th element in <code>g1</code> to the element of index <code>p.apply(i)</code>
     * in the group <code>g2</code>.
     */
    public static Optional<Permutation> computeIsomorphismP(FiniteGroup<?> g1, FiniteGroup<?> g2) {
        if (g1.index() != g2.index()) {
            return Optional.empty();
        }
        int[][] table1 = g1.groupTable(),
                table2 = g2.groupTable();
        int size = Math.toIntExact(g1.index());
        int[] map = ArraySup.fillArr(size, -1);
        //identity element must be equal
        map[0] = 0;
        map = recurEqual(size, table1, table2, map, 0);
        if (map == null) {
            return Optional.empty();
        }
        return Optional.of(Permutations.valueOf(map));
    }

    /**
     * Determines whether the two finite groups are isomorphic and returns the isomorphism as a mapping.
     */
    public static <T, R> Optional<IsomorphismMapping<T, R>> computeIsomorphism(FiniteGroup<T> g1, FiniteGroup<R> g2) {
        if (g1.index() != g2.index()) {
            return Optional.empty();
        }
        int[][] table1 = g1.groupTable(),
                table2 = g2.groupTable();
        int size = Math.toIntExact(g1.index());
        int[] map = ArraySup.fillArr(size, -1);
        //identity element must be equal
        map[0] = 0;
        map = recurEqual(size, table1, table2, map, 0);
        if (map == null) {
            return Optional.empty();
        }
        int[] fmap = map;
        var bi = new IsomorphismMapping<T, R>() {
            @SuppressWarnings("unchecked")
            T[] arr1 = (T[]) CollectionSup.iteratorToArray(g1.getSet().iterator(), size);
            @SuppressWarnings("unchecked")
            R[] arr2 = (R[]) CollectionSup.iteratorToArray(g2.getSet().iterator(), size);

            @NotNull
            @Override
            public R apply(@NotNull T x) {
                int idx1 = ArraySup.firstIndexOf(arr1, y -> g1.getCalculator().isEqual(x, y));
                int idx2 = fmap[idx1];
                return arr2[idx2];
            }

            @Override
            public T deply(@NotNull R y) {
                int idx2 = ArraySup.firstIndexOf(arr2, x -> g2.getCalculator().isEqual(x, y));
                int idx1 = ArraySup.firstIndexOf(idx2, fmap);
                return arr1[idx1];
            }
        };
        return Optional.of(bi);
    }

    /**
     * A recursive method to determine whether two group tables are isomorphic and returns the mapping.
     *
     * @param cur the newest that is assigned
     */
    static int[] recurEqual(int size, int[][] t1, int[][] t2, int[] map, int cur) {
        for (int i = 0; i < size; i++) {
            if (map[i] == -1) {
                //assign the value
                for (int val = 0; val < size; val++) {
                    if (ArraySup.firstIndexOf(val, map) > -1) {
                        //already assigned
                        continue;
                    }
                    map[i] = val;
                    int[] tMap = recurEqual(size, t1, t2, map, i);
                    if (tMap == null) {
                        //failed
                        map[i] = -1;
                    } else {
                        return tMap;
                    }
                }
                if (map[i] == -1) {
                    //all failed
                    return null;
                }
            } else {
                int a = t1[i][cur];
                int b = t2[map[i]][map[cur]];
                int aMap = map[a];
                if (aMap == -1) {
                    map[a] = b;
                    return recurEqual(size, t1, t2, map, a);
                }
                if (aMap != b) {
                    return null;
                }

                a = t1[cur][i];
                b = t2[map[cur]][map[i]];
                aMap = map[a];
                if (aMap == -1) {
                    map[a] = b;
                    return recurEqual(size, t1, t2, map, a);
                }
                if (aMap != b) {
                    return null;
                }
            }
        }
        return map;
    }

//    public static void main(String[] args) {
//        var g1 = PermutationGroup.symmetricGroup(3);
//        print(g1.getSet());
//        print(homoEqualsAndPermutation(g1,g1));
//    }

    /**
     * Returns the outer product of the two groups. The set of the corresponding group is
     * the cartesian product of the sets of the two groups, the operation is define as:
     * <pre>
     *     (g1,h1) * (g2,h2) = (g1g2, h1h2)
     * </pre>
     */
    public static <T, N> AbstractFiniteGroup<Pair<T, N>> outerProduct(FiniteGroup<T> g, FiniteGroup<N> h) {
        var gc = g.getCalculator();
        var hc = h.getCalculator();
        var ngc = new GroupCalculator<Pair<T, N>>() {

            @Override
            public boolean isEqual(@NotNull Pair<T, N> x, @NotNull Pair<T, N> y) {
                return gc.isEqual(x.getFirst(), y.getFirst()) && hc.isEqual(x.getSecond(), y.getSecond());
            }

            @NotNull
            @Override
            public Pair<T, N> apply(@NotNull Pair<T, N> x, @NotNull Pair<T, N> y) {
                var a = gc.apply(x.getFirst(), y.getFirst());
                var b = hc.apply(x.getSecond(), y.getSecond());
                return new Pair<>(a, b);
            }

            private final Pair<T, N> id = new Pair<>(gc.getIdentity(), hc.getIdentity());

            @NotNull
            @Override
            public Pair<T, N> getIdentity() {
                return id;
            }

            @NotNull
            @Override
            public Pair<T, N> inverse(@NotNull Pair<T, N> x) {
                var a = gc.inverse(x.getFirst());
                var b = hc.inverse(x.getSecond());
                return new Pair<>(a, b);
            }
        };
        var nset = MathSets.cartesianProduct(g.getSet(), h.getSet());
        return new FiniteGroupImpl<>(ngc, nset);
    }


    /**
     * Returns the commutator group of g. That is, the subgroup of <code>g</code> containing all the elements like
     * <pre>a<sup>-1</sup>b<sup>-1</sup>ab</pre>
     *
     * @see GroupCalculatorKt#commutator(GroupCalculator, Object, Object)
     */

    public static <T> AbstractFiniteGroup<T> commutatorGroup(FiniteGroup<T> g) {
//        GroupCalculatorKt.commutator()
        var gc = g.getCalculator();
        if (gc.isCommutative()) {
            return identityGroup(gc);
        }
        if (g.getCalculator().getIdentity() instanceof Comparable) {
            @SuppressWarnings("unchecked")
            var comp = (Comparator<T>) Comparator.naturalOrder();
            return commutatorGroup(g, comp);
        }
        var list = new ArrayList<T>();
        var elements = g.getSet();
        for (var a : elements) {
            for (var b : elements) {
                var c = GroupCalculatorKt.commutator(gc, a, b);
                if (!CollectionSup.containsEqual(list, gc, c)) {
                    list.add(c);
                }
            }
        }
        generateList(list, gc);
        return createGroupWithoutCheck(gc, list);
    }

    /**
     * Returns the commutator group of g. That is, the subgroup of <code>g</code> containing all the elements like
     * <pre>a<sup>-1</sup>b<sup>-1</sup>ab</pre>
     *
     * @see GroupCalculatorKt#commutator(GroupCalculator, Object, Object)
     */
    public static <T> AbstractFiniteGroup<T> commutatorGroup(FiniteGroup<T> g, Comparator<T> comp) {
        var gc = g.getCalculator();
        if (gc.isCommutative()) {
            return identityGroup(gc);
        }
        var s = new TreeSet<>(comp);
        var elements = g.getSet();
        for (var a : elements) {
            for (var b : elements) {
                var c = GroupCalculatorKt.commutator(gc, a, b);
                s.add(c);
            }
        }
        generateComparable(s, gc);
        return createGroupWithoutCheck(gc, s);
    }


}
