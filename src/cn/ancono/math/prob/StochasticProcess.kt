package cn.ancono.math.prob

import cn.ancono.math.algebra.abs.calculator.AbelGroupCal
import cn.ancono.math.algebra.linear.Matrix
import cn.ancono.math.algebra.linear.Vector
import cn.ancono.math.numberModels.Calculators
import java.util.*
import java.util.function.Function
import java.util.function.Predicate


/*
 * Created by liyicheng at 2021-05-12 14:45
 */

interface GeneralStochasticProcess<T, R> : RandomVariable<Function<T, R>> {

    fun sampleAt(t: T): R

    /**
     * Gets the random variable at a time.
     */
    fun rvAt(t: T): RandomVariable<R>
}

interface DiscreteTimeStochasticProcess<R> : GeneralStochasticProcess<Int, R> {

    /**
     * @param t inclusive
     */
    fun sampleTo(t: Int): List<R>

    fun randomVariableTo(t: Int): RandomVariable<List<R>>

}

typealias Realization<R> = Function<Time, R>


fun <R> Realization<R>.shift(n: Int): Realization<R> = Function { t ->
    this.apply(t + n)
}

/**
 * A stochastic process is a family of random variable `{X_n, n ≥ 0}` defined on a probability space
 * `(Ω, F)` with a probability measure `P`, which are adapted to the filtration `{F_n, n ≥ 0}`.
 *
 * We take the probability to be the canonical product space
 * `(Ω, F) = (R^∞, B^∞)` and each point `ω ∈ Ω` is a sequence `ω = (ω_n, n ≥ 0)`,
 * and `X_n` is simply the coordinate random variable which is defined by `X_n(ω) = ω_n`.
 * The sub-σ-field `F_n` is the σ-field generated by `X_0,...,X_n`.
 *
 * In programming, the point `ω ∈ Ω` is represented by
 * `Realization<R> := Function<Time, R>`, so a stochastic process is actually a random variable
 * taking values as `Realization<R>`.
 * The random variable `X_n` can be taken using the function [GeneralStochasticProcess.rvAt].
 *
 * Sampling from a stochastic process is a bit different from the regular random variables,
 * since we can not completely determine the realization which is infinite. Therefore, the realization is
 * actually lazily computed and cached to ensure the consistency of different random variables relying on the same
 * probability space. However, it is unnecessary for simple sampling, where only a sequence of sample values are
 * needed. In this situation, [sampleAsSeq] can be used, which provides i.i.d. samples for each iteration of the
 * sequence.
 *
 *
 *
 */
interface StochasticProcess<R> : DiscreteTimeStochasticProcess<R>, SimpleRV<Realization<R>, Realization<R>> {

    /**
     * Gets a sequence of samples, which provides i.i.d. samples for each iteration of the
     * sequence. Consecutive iterations of the sequence will result in different samples.
     */
    fun sampleAsSeq(): Sequence<R>


//    /**
//     * Gets a random variable that returns a sequence of `R` instead of a realization,
//     */
//    fun randomVariableSeq(): RandomVariable<Sequence<R>>
//
//
//    fun randomVariableSeqCollected(): RandomVariable<Sequence<List<R>>> {
//        return map { f ->
//            sequence {
//                val list = arrayListOf<R>()
//                for (i in 0..Int.MAX_VALUE) {
//                    list.add(f.apply(i))
//                    yield(list)
//                }
//            }
//        }
//    }


    /**
     * Creates a stopping time.
     */
    fun stoppingTime(predicate: Predicate<List<R>>): StoppingTime<R> {
        return StoppingTime(this, predicate)
    }

    /**
     * Creates a hitting time:
     * > T = min { n ≥ 0 : predicate.test(X_n) == true }
     */
    fun hittingTime(predicate: Predicate<R>): StoppingTime<R> {
        return HittingTime(this, predicate)
    }

    /**
     * Creates a hitting time:
     * > T = min { n ≥ 0 : X_n == r }
     */
    fun hittingTimeOf(r: R): HittingTime<R> {
        return HittingTime(this, Predicate.isEqual(r))
    }

    /**
     * Returns a random variable of a stopping time: `X_T`.
     *
     */
    fun rvAt(T: StoppingTime<R>): RandomVariable<R> {
        return map { r -> r.apply(T.fromRealization(r)) }
    }

    fun sampleAt(T: StoppingTime<R>): R {
        return T.sampleX()
    }

    fun sampleTo(T: StoppingTime<R>): List<R> {
        val r = sample()
        val t = T.fromRealization(r)
        return (0..t).map { r.apply(it) }
    }

    fun randomVariableTo(T: StoppingTime<R>): RandomVariable<List<R>> {
        return map { r ->
            val t = T.fromRealization(r)
            (0..t).map { r.apply(it) }
        }
    }

    /**
     * Shifts this stochastic process with a stopping time, resulting in a stochastic process of
     * > X_T, X_{T+1}, ...
     */
    fun shift(T: StoppingTime<R>): StochasticProcess<R> {
        return ShiftedStochasticProcess(this, T)
    }


}

/**
 * A stopping time `T` is a random variable of `Time` that satisfies:
 * > { T = n } ∈ F_n
 *
 * Therefore, it can be determined whether `T` will take the value `n`
 * using the values of the stochastic process from `0` to `n`.
 *
 * In programming, a predicate that takes a list of `R` which is the values of `X_0,...,X_n` should be
 * provided to create a stopping time.
 */
open class StoppingTime<R>(
        val process: StochasticProcess<R>,
        val predicate: Predicate<List<R>>
) : RandomVariable<Time> {
    override val spaces: Set<ProbSpace<*>>
        get() = process.spaces

    open fun fromRealization(r: Realization<R>): Time {
        val list = arrayListOf<R>()
        for (i in 0..Int.MAX_VALUE) {
            list.add(r.apply(i))
            if (predicate.test(list)) {
                return i
            }
        }
        throw ArithmeticException("Stopping time overflow!")
    }


    override fun fromEvent(event: Event): Time {
        val r = process.fromEvent(event)
        return fromRealization(r)
    }

    override fun sample(): Time {
        return fromRealization(process.sample())
    }

    open fun sampleX(): R {
        val r = process.sample()
        val t = fromRealization(r)
        return r.apply(t)
    }

    open infix fun min(y: StoppingTime<R>): StoppingTime<R> {
        require(this.process == y.process)
        return StoppingTime(process, predicate.or(y.predicate))
    }

    open infix fun min(n: Int): StoppingTime<R> {
        return StoppingTime(process) { it.lastIndex >= n || predicate.test(it) }
    }

    open operator fun plus(n: Int): StoppingTime<R> {
        return StoppingTime(process) { it.size > n && predicate.test(it.subList(n, it.size)) }
    }

    /**
     * Returns a random variable of the indicator function:
     * > 1{ this < y }
     */
    open infix fun lessThan(y: StoppingTime<R>): RandomVariable<Int> {
        return process.map { r ->
            val list = arrayListOf<R>()
            for (i in 0..Int.MAX_VALUE) {
                list.add(r.apply(i))
                if (y.predicate.test(list)) {
                    return@map 0
                }
                if (predicate.test(list)) {
                    return@map 1
                }
            }
            throw ArithmeticException("Stopping time overflow!")
        }
    }

    /**
     * Returns a random variable of the indicator function:
     * > 1{ this ≤ y }
     */
    open infix fun leqThen(y: StoppingTime<R>): RandomVariable<Int> {
        return process.map { r ->
            val list = arrayListOf<R>()
            for (i in 0..Int.MAX_VALUE) {
                list.add(r.apply(i))
                if (predicate.test(list)) {
                    return@map 1
                }
                if (y.predicate.test(list)) {
                    return@map 0
                }
            }
            throw ArithmeticException("Stopping time overflow!")
        }
    }

    companion object {

        fun <R> constant(process: StochasticProcess<R>, n: Int): StoppingTime<R> {
            return StoppingTime(process) { it.lastIndex == n }
        }
    }

}


class HittingTime<R>(process: StochasticProcess<R>, val isHit: Predicate<R>)
    : StoppingTime<R>(process, Predicate { isHit.test(it.last()) }) {
    override fun fromRealization(r: Realization<R>): Time {
        for (i in 0..Int.MAX_VALUE) {
            if (isHit.test(r.apply(i))) {
                return i
            }
        }
        throw ArithmeticException("Stopping time overflow!")
    }

    override fun sample(): Time {
        return process.sampleAsSeq().indexOfFirst { isHit.test(it) }
    }

    override fun sampleX(): R {
        return process.sampleAsSeq().first { isHit.test(it) }
    }


    override fun min(y: StoppingTime<R>): StoppingTime<R> {
        require(process == y.process)
        if (y is HittingTime) {
            return HittingTime(this.process, isHit.or(y.isHit))
        }
        return super.min(y)
    }


}

class ShiftedStochasticProcess<R>(val origin: StochasticProcess<R>, val N: StoppingTime<R>) : StochasticProcess<R> {
    override val space: ProbSpace<Realization<R>>
        get() = origin.space

    override fun fromPoint(e: Realization<R>): Realization<R> {
        val t = N.fromRealization(e)
        return e.shift(t)
    }

    override fun sampleAt(t: Int): R {
        return origin.sampleAt(N)
    }

    override fun rvAt(t: Int): RandomVariable<R> {
        return origin.rvAt(N + t)
    }

    override fun sampleTo(t: Int): List<R> {
        return origin.sampleTo(N + t)
    }

    override fun randomVariableTo(t: Int): RandomVariable<List<R>> {
        return origin.randomVariableTo(N + t)
    }

    override fun sampleAsSeq(): Sequence<R> {
        val r = origin.sample()
        val t = N.fromRealization(r)
        return (t..Int.MAX_VALUE).asSequence().map { r.apply(it) }
    }


    override fun sample(): Function<Int, R> {
        val r = origin.sample()
        val t = N.fromRealization(r)
        return r.shift(t)
    }
}

interface Martingale<R> : StochasticProcess<R>


object StochasticProcesses {

    /**
     * Returns a random walk starting from [start].
     */
    fun <T> randomWalk(start: T, X: RandomVariable<T>, mc: AbelGroupCal<T>): MarkovChain<T> {
        return MarkovChain(RandomWalkSpace(mc, start, X::sample))
    }

    /**
     * Creates a
     */
    fun simpleRandomWalk(p: Double = 0.5, start: Int = 0): MarkovChain<Int> {
        val rd = Random()
        val space = RandomWalkSpace(Calculators.integer(), start) {
            if (rd.nextDouble() <= p) {
                1
            } else {
                -1
            }
        }
        return MarkovChain(space)
    }

    fun simpleSymmetricRW(start: Int = 0): MarkovChain<Int> {
        return simpleRandomWalk(0.5, start)
    }

    fun markovChain(mu0: Vector<Double>, transition: Matrix<Double>): MarkovChain<Int> {
        val space = MarkovSpaceWithTransition.of(mu0, transition)
        return MarkovChain(space)
    }

    fun branching(X: RandomVariable<Int>): MarkovChain<Int> {
        val space = BranchingSpace(X::sample)
        return MarkovChain(space)
    }

    fun birthDeathChain(p: Double, q: Double): MarkovChain<Int> {
        return MarkovChain(BirthDeathSpace.of(p, q))
    }

}


fun main() {
//    val X = RandomVariables.bernoulli(18.0 / 38).map { it * 2 - 1 }
//    val rw = RandomProcesses.randomWalk(20, X, Calculators.integer())
    val rw = StochasticProcesses.simpleRandomWalk(18.0 / 38)
    val T0 = rw.hittingTimeOf(0)
    val T1 = rw.hittingTimeOf(40)
    val T = T0 min T1
//    val e = RandomVariables.estimateExpectation(T.map { it.toDouble() })
    val X_T = rw.rvAt(T) // X_T
//    println(e)
    val Z = RandomVariables.map2(rw, T) { r, t ->
        r.apply(t)
    }
    println(Z.samples().take(100).toList())
    println(X_T.samples().take(100).toList())

}