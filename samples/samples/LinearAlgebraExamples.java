package samples;

import cn.ancono.math.algebra.linear.*;
import cn.ancono.math.geometry.analytic.space.SVector;
import cn.ancono.math.numberModels.Calculators;
import cn.ancono.math.numberModels.Fraction;
import cn.ancono.math.numberModels.Multinomial;

import static cn.ancono.math.numberModels.Fraction.of;

/*
 * Created by lyc at 2020/2/29
 */
public class LinearAlgebraExamples {
    public static void sample1() {
        var cal = Calculators.integer();
        var calFrac = Fraction.getCalculator();
        var m1 = Matrix.of(2, 2, cal,
                1, 2,
                4, 5)
                .mapTo(calFrac, Fraction::of);
        var m2 = Matrix.of(2, 2, cal,
                3, -6,
                -4, 8)
                .mapTo(calFrac, Fraction::of);
        var m3 = m1.multiply(m2);
        System.out.println(m3);
        var det = m3.det();
        var rank = m3.rank();
        System.out.println("Det of the matrix: " + det);
        System.out.println("Rank of the matrix: " + rank);
    }

    public static void quadraticForm() {
        var expr = "10x^2+8xy+24xz+2y^2-28yz+z^2";
        var A = QuadraticForm.representationMatrix(Multinomial.parse(expr));
        System.out.println("A = \n" + A);
        var pair = A.toCongDiagForm();
        var J = pair.getFirst();
        var P = pair.getSecond();
        System.out.println("P = \n" + P);
        System.out.println("J = \n" + J);
        System.out.println("P^T * A * P = ");
        // P^T*A*P = J
        System.out.println(Matrix.product(P.transpose(), A, P));
    }

    public static void linearSpace() {
        //import static cn.ancono.math.numberModels.Fraction.of;
        var mc = Fraction.getCalculator();
        var v1 = Vector.of(mc, of(1), of(2), of(3));
        var v2 = Vector.of(mc, of(2), of(4), of(6));
        var v3 = Vector.of(mc, of(1), of(2), of(5));
        var basis = VectorBasis.generate(v1, v2, v3);
        System.out.println("The basis is generated by: " + v1 + "," + v2 + "," + v3);
        System.out.println("Its rank is " + basis.getRank());
        var v = Vector.of(mc, Fraction.ONE, of(2), of(0));
        System.out.println("Reducing the vector " + v);
        System.out.println("Can reduce? " + basis.canReduce(v));
        var coe = basis.reduce(v);
        System.out.println("Coefficients = " + coe);
    }

    public static void vector() {
        var mc = Calculators.doubleDev();
        var u = SVector.valueOf(1., 2., 3., mc).unitVector();
        var v = SVector.valueOf(2., 3., 4., mc);
        // SVector: vector in space (R^3), outer product is supported
        System.out.println("u = " + u);
        System.out.println("v = " + v);
        System.out.println("u+v = " + u.add(v));
        System.out.println("<u,v> = " + u.innerProduct(v));
        System.out.println("u Ã— v = " + u.outerProduct(v));
    }

    public static void verifyCaleyHamilton() {
        var mc = Fraction.getCalculator();
        var m = MatrixSup.parseFMatrix("1 1 0\n0 1 0\n0 0 2");
        System.out.println("M = \n" + m);
        var f = m.charPoly();
        System.out.println("Characteristic polynomial f(x) = " + f);
        var matrixCal = Matrix.calculatorFor(m);
        var fm = f.mapTo(matrixCal, x -> Matrix.diag(x, 3, mc));
        var result = fm.compute(m);
        System.out.println("f(M) = \n" + result); // Caley-Hamilton theorem
    }


    public static void main(String[] args) {
//        sample1();
//        System.out.println();
//        quadraticForm();
//        System.out.println();
//        vector();
//        System.out.println();
        verifyCaleyHamilton();
    }
}
